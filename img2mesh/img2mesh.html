<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PNGè½¬3Dç½‘æ ¼å·¥å…· (ä¸¥æ ¼å‡¸æ€§ä¿®å¤ç‰ˆ)</title>
    <style>
        :root { --bg: #2b2b2b; --panel: #3c3f41; --text: #e0e0e0; --accent: #4a90e2; --border: #555; --success: #4caf50; }
        body { margin: 0; font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); height: 100vh; display: flex; overflow: hidden; user-select: none; }
        
        .sidebar { width: 320px; background: var(--panel); border-right: 1px solid var(--border); padding: 15px; display: flex; flex-direction: column; gap: 15px; overflow-y: auto; flex-shrink: 0; z-index: 2; box-shadow: 2px 0 10px rgba(0,0,0,0.3); }
        .main-view { flex-grow: 1; position: relative; background: #1e1e1e; overflow: hidden; cursor: grab; }
        .main-view.picking { cursor: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IndoaXRlIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3R5bGU9ImZpbHRlcDogZHJvcC1zaGFkb3coMXB4IDFweCAycHggYmxhY2spOyI+PHBhdGggZD0iTTIgMjJsNS01Ii8+PHBhdGggZD0iTTEzLjUgNi41bDUgNSIvPjxwYXRoIGQ9Ik0yMS4yMSA4LjM0YTIuMTIgMi4xMiAwIDAwMC0zbC0zLjM1LTMuMzRhMi4xMiAyLjEyIDAgMDAtMyAwTDQuNSAxMi4zNiAyIDIybDkuNjQtMi41IDEwLjM2LTEwLjM2LTEwLjM2eiIvPjwvc3ZnPg==') 0 24, crosshair; }
        .main-view:active { cursor: grabbing; }
        
        .step-header { font-size: 14px; font-weight: bold; color: var(--accent); border-bottom: 1px solid #555; padding-bottom: 5px; margin-bottom: 10px; display: flex; align-items: center; }
        .step-badge { background: var(--accent); color: white; border-radius: 50%; width: 20px; height: 20px; text-align: center; line-height: 20px; font-size: 12px; display: inline-block; margin-right: 8px; font-weight: bold; }
        
        .control-group { background: rgba(0,0,0,0.25); padding: 12px; border-radius: 6px; border: 1px solid #484848; margin-bottom: 5px; }
        label { display: block; font-size: 12px; margin-bottom: 6px; color: #ccc; font-weight: 500; }
        
        .slider-row { display: flex; align-items: center; gap: 10px; }
        input[type="range"] { flex-grow: 1; cursor: pointer; height: 4px; border-radius: 2px; }
        span.value { width: 45px; text-align: right; font-size: 12px; font-family: monospace; color: var(--accent); font-weight: bold; }
        
        button { background: #555; color: white; border: none; padding: 10px 12px; border-radius: 4px; cursor: pointer; font-size: 13px; transition: all 0.2s; width: 100%; border: 1px solid rgba(255,255,255,0.1); }
        button:hover { background: #666; border-color: rgba(255,255,255,0.2); }
        button:disabled { background: #333; color: #666; cursor: not-allowed; border-color: transparent; }
        
        .btn-primary { background: var(--accent); font-weight: bold; padding: 12px; font-size: 14px; margin-top: 5px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); border: none; }
        .btn-primary:hover { background: #357abd; transform: translateY(-1px); }
        .btn-primary:active { transform: translateY(1px); }
        
        .btn-export { background: var(--success); font-weight: bold; height: 45px; font-size: 14px; border: none; }
        .btn-export:hover { background: #43a047; }
        
        .eyedropper-toggle { display: flex; align-items: center; justify-content: space-between; background: #444; padding: 8px 10px; border-radius: 4px; cursor: pointer; border: 1px solid #555; transition: all 0.2s; }
        .eyedropper-toggle:hover { background: #505050; border-color: #777; }
        .eyedropper-toggle.active { background: rgba(74, 144, 226, 0.15); border-color: var(--accent); color: var(--accent); }
        .eyedropper-toggle input { display: none; }
        
        #fileInput { display: none; }
        
        .status-bar { position: fixed; bottom: 0; left: 320px; right: 0; background: var(--panel); padding: 0 15px; height: 30px; font-size: 12px; border-top: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; color: #aaa; z-index: 2; }
        
        .progress-container { width: 150px; height: 6px; background: #222; border-radius: 3px; overflow: hidden; display: none; margin-left: 10px; }
        .progress-bar { height: 100%; background: var(--success); width: 0%; transition: width 0.1s linear; }

        .color-preview { width: 20px; height: 20px; border: 2px solid #fff; border-radius: 4px; display: inline-block; vertical-align: middle; margin-right: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }

        .view-controls { position: absolute; top: 15px; right: 15px; background: rgba(43, 43, 43, 0.9); padding: 10px; border-radius: 8px; backdrop-filter: blur(4px); z-index: 10; display: flex; flex-direction: column; gap: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.4); border: 1px solid #555; }
        .view-controls label { margin: 0; cursor: pointer; font-weight: bold; font-size: 12px; color: #eee; display: flex; align-items: center; gap: 8px; }
        .view-controls input { accent-color: var(--accent); }

        .mode-indicator {
            position: absolute; top: 15px; left: 15px; z-index: 10;
            padding: 6px 12px; border-radius: 4px; font-size: 12px; font-weight: bold;
            backdrop-filter: blur(4px); box-shadow: 0 2px 5px rgba(0,0,0,0.3); pointer-events: none;
            transition: all 0.3s ease;
        }
        .mode-mask { background: rgba(244, 67, 54, 0.9); color: white; border: 1px solid #d32f2f; }
        .mode-mesh { background: rgba(76, 175, 80, 0.9); color: white; border: 1px solid #388e3c; }
        .hidden { display: none !important; }
        
        .opt-badge { color: #88ff88; font-size: 10px; margin-left: 5px; opacity: 0.8; }
    </style>
</head>
<body>

    <div class="sidebar">
        <div style="margin-bottom: 15px;">
            <button onclick="document.getElementById('fileInput').click()" style="background: #444; border: 1px dashed #777; height: 40px;">ğŸ“‚ æ‰“å¼€å›¾ç‰‡ (PNG)</button>
            <input type="file" id="fileInput" accept="image/png" onchange="handleFileSelect(event)">
        </div>

        <div class="step-header">
            <span class="step-badge">1</span> å®šä¹‰é®ç½© (æŠ å›¾)
        </div>
        
        <div class="control-group">
            <label class="eyedropper-toggle" id="eyedropperBtn" title="ç‚¹å‡»å¯ç”¨ï¼Œç„¶ååœ¨ç”»å¸ƒä¸Šç‚¹å‡»é¢œè‰²">
                <span>ğŸ–Œï¸ å¸ç®¡å·¥å…· (ç‚¹å›¾å¸è‰²)</span>
                <input type="checkbox" id="colorPickerMode" onchange="toggleColorPicker()">
            </label>
            
            <div id="keyColorDisplay" class="hidden" style="background: #333; padding: 8px; border-radius: 4px; margin: 8px 0; border: 1px solid #555;">
                <div style="display:flex; align-items:center; justify-content: space-between;">
                    <div style="display:flex; align-items:center;">
                        <div id="keyColorBox" class="color-preview"></div>
                        <span id="keyColorText" style="font-weight:bold; font-size: 12px; color: #fff;"></span>
                    </div>
                    <button style="width:auto; padding: 2px 8px; font-size: 11px; height: 20px;" onclick="clearKeyColor()">æ¸…é™¤</button>
                </div>
            </div>

            <label id="thresholdLabel" style="margin-top:10px;">Alpha é˜ˆå€¼</label>
            <div class="slider-row">
                <input type="range" id="commonThreshold" min="1" max="100" value="50" oninput="updateMaskPreview()">
                <span class="value" id="val-commonThreshold">50</span>
            </div>
            
            <label style="margin-top:10px;">é€‰åŒºè†¨èƒ€ (Dilate)</label>
            <div class="slider-row">
                <input type="range" id="expansion" min="0" max="20" value="0" oninput="updateMaskPreview()">
                <span class="value" id="val-expansion">0</span>
            </div>
        </div>

        <button id="generateBtn" class="btn-primary" onclick="startMeshGeneration()" disabled>
            â–¶ ç”Ÿæˆç½‘æ ¼ <span class="opt-badge">Convex Fix</span>
        </button>
        <div style="text-align: center; font-size: 11px; color: #888; margin-top: 5px;">* ä¸¥æ ¼å‡¸æ€§æ£€æµ‹ & å…±çº¿æ¸…ç†</div>

        <div style="height: 15px;"></div>

        <div class="step-header">
            <span class="step-badge">2</span> ç½‘æ ¼ä¼˜åŒ–
        </div>
        <div class="control-group">
            <label>è¾¹ç¼˜ç²¾åº¦ (å€¼è¶Šå°è¶Šç²¾ç»†)</label>
            <div class="slider-row">
                <input type="range" id="precision" min="1" max="200" value="20" oninput="updateMeshIfPossible()">
                <span class="value" id="val-precision">2.0px</span>
            </div>
        </div>

        <div style="margin-top: auto;">
            <button onclick="resetView()" style="margin-bottom: 10px;">â†º é‡ç½®ç”»å¸ƒè§†è§’</button>
            <button id="exportBtn" class="btn-export" onclick="exportModel()" disabled>â¬‡ å¯¼å‡º OBJ</button>
        </div>
    </div>

    <div class="main-view" id="mainView">
        <div id="modeBadge" class="mode-indicator hidden">å½“å‰æ¨¡å¼</div>
        <div class="view-controls">
            <label>
                <input type="checkbox" id="showMaskPreview" checked onchange="requestAnimationFrame(draw)">
                <span>æ˜¾ç¤ºçº¢è‰²é®ç½© (è°ƒè¯•)</span>
            </label>
            <label>
                <input type="checkbox" id="showWireframe" checked onchange="requestAnimationFrame(draw)">
                <span>æ˜¾ç¤ºçº¿æ¡† (Wireframe)</span>
            </label>
            <label>
                <input type="checkbox" id="showPoints" checked onchange="requestAnimationFrame(draw)">
                <span>æ˜¾ç¤ºé¡¶ç‚¹ (Vertices)</span>
            </label>
        </div>
        <canvas id="canvas"></canvas>
    </div>
    
    <div class="status-bar">
        <span id="statusBar">å°±ç»ª</span>
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        <span id="polyCount" style="font-family: monospace; color: var(--accent); font-weight: bold;"></span>
    </div>

<script>
// --- æ ¸å¿ƒç®—æ³• 1: Earcut (åŸºç¡€ä¸‰è§’åŒ–) ---
const earcut=(function(){function earcut(data,holeIndices,dim){dim=dim||2;var hasHoles=holeIndices&&holeIndices.length,outerLen=hasHoles?holeIndices[0]*dim:data.length,outerNode=linkedList(data,0,outerLen,dim,true),triangles=[];if(!outerNode||outerNode.prev===outerNode)return triangles;var minX,minY,maxX,maxY,x,y,invSize;if(hasHoles)outerNode=eliminateHoles(data,holeIndices,outerNode,dim);if(data.length>80*dim){minX=maxX=data[0];minY=maxY=data[1];for(var i=dim;i<outerLen;i+=dim){x=data[i];y=data[i+1];if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;}invSize=Math.max(maxX-minX,maxY-minY);invSize=invSize!==0?1/invSize:0;}earcutLinked(outerNode,triangles,dim,minX,minY,invSize);return triangles;}function linkedList(data,start,end,dim,clockwise){var i,last;if(clockwise===(signedArea(data,start,end,dim)>0)){for(i=start;i<end;i+=dim)last=insertNode(i,data[i],data[i+1],last);}else{for(i=end-dim;i>=start;i-=dim)last=insertNode(i,data[i],data[i+1],last);}if(last&&equals(last,last.next)){removeNode(last);last=last.next;}return last;}function filterPoints(start,end){if(!start)return start;if(!end)end=start;var p=start,again;do{again=false;if(!p.steiner&&(equals(p,p.next)||area(p.prev,p,p.next)===0)){removeNode(p);p=end=p.prev;if(p===p.next)break;again=true;}else{p=p.next;}}while(again||p!==end);return end;}function earcutLinked(ear,triangles,dim,minX,minY,invSize,pass){if(!ear)return;if(!pass&&invSize)indexCurve(ear,minX,minY,invSize);var stop=ear,prev,next;while(ear.prev!==ear.next){prev=ear.prev;next=ear.next;if(invSize?isEarHashed(ear,minX,minY,invSize):isEar(ear)){triangles.push(prev.i/dim);triangles.push(ear.i/dim);triangles.push(next.i/dim);removeNode(ear);ear=next.next;stop=next.next;continue;}ear=next;if(ear===stop){if(!pass){earcutLinked(filterPoints(ear),triangles,dim,minX,minY,invSize,1);}else if(pass===1){earcutLinked(cureLocalIntersections(filterPoints(ear),triangles,dim),triangles,dim,minX,minY,invSize,2);}else if(pass===2){splitEarcut(ear,triangles,dim,minX,minY,invSize);}break;}}}function isEar(ear){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;var p=ear.next.next;while(p!==ear.prev){if(pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.next;}return true;}function isEarHashed(ear,minX,minY,invSize){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;var minTX=a.x<b.x?(a.x<c.x?a.x:c.x):(b.x<c.x?b.x:c.x),minTY=a.y<b.y?(a.y<c.y?a.y:c.y):(b.y<c.y?b.y:c.y),maxTX=a.x>b.x?(a.x>c.x?a.x:c.x):(b.x>c.x?b.x:c.x),maxTY=a.y>b.y?(a.y>c.y?a.y:c.y):(b.y<c.y?b.y:c.y);var minZ=zOrder(minTX,minTY,minX,minY,invSize),maxZ=zOrder(maxTX,maxTY,minX,minY,invSize);var p=ear.prevZ,n=ear.nextZ;while(p&&p.z>=minZ&&n&&n.z<=maxZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ;if(n!==ear.prev&&n!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,n.x,n.y)&&area(n.prev,n,n.next)>=0)return false;n=n.nextZ;}while(p&&p.z>=minZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ;}while(n&&n.z<=maxZ){if(n!==ear.prev&&n!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,n.x,n.y)&&area(n.prev,n,n.next)>=0)return false;n=n.nextZ;}return true;}function cureLocalIntersections(start,triangles,dim){var p=start;do{var a=p.prev,b=p.next.next;if(!equals(a,b)&&intersects(a,p,p.next,b)&&locallyInside(a,b)&&locallyInside(b,a)){triangles.push(a.i/dim);triangles.push(p.i/dim);triangles.push(b.i/dim);removeNode(p);removeNode(p.next);p=start=b;}p=p.next;}while(p!==start);return filterPoints(p);}function splitEarcut(start,triangles,dim,minX,minY,invSize){var a=start;do{var b=a.next.next;while(b!==a.prev){if(a.i!==b.i&&isValidDiagonal(a,b)){var c=splitPolygon(a,b);a=filterPoints(a,a.next);c=filterPoints(c,c.next);earcutLinked(a,triangles,dim,minX,minY,invSize);earcutLinked(c,triangles,dim,minX,minY,invSize);return;}b=b.next;}a=a.next;}while(a!==start);}function eliminateHoles(data,holeIndices,outerNode,dim){var queue=[],i,len,start,end,list;for(i=0,len=holeIndices.length;i<len;i++){start=holeIndices[i]*dim;end=i<len-1?holeIndices[i+1]*dim:data.length;list=linkedList(data,start,end,dim,false);if(list===list.next)list.steiner=true;queue.push(getLeftmost(list));}queue.sort(compareX);for(i=0;i<queue.length;i++){eliminateHole(queue[i],outerNode);outerNode=filterPoints(outerNode,outerNode.next);}return outerNode;}function eliminateHole(hole,outerNode){var bridge=findHoleBridge(hole,outerNode);if(bridge){var bridgeReverse=splitPolygon(bridge,hole);filterPoints(bridgeReverse,bridgeReverse.next);filterPoints(bridge,bridge.next);}}function findHoleBridge(hole,outerNode){var p=outerNode,hx=hole.x,hy=hole.y,qx=-Infinity,m;do{if(hy<=p.y&&hy>=p.next.y&&p.next.y!==p.y){var x=p.x+(hy-p.y)*(p.next.x-p.x)/(p.next.y-p.y);if(x<=hx&&x>qx){qx=x;if(x===hx&&hy===p.y)return p;m=p;}}p=p.next;}while(p!==outerNode);if(!m)return null;if(hole.x===m.x)return m;var stop=m,mx=m.x,my=m.y,tanMin=Infinity,tan;p=m;do{if(hx>=p.x&&p.x>=mx&&hx!==p.x&&pointInTriangle(hy<my?hx:qx,hy,mx,my,hy<my?qx:hx,hy,p.x,p.y)){tan=Math.abs(hy-p.y)/(hx-p.x);if(locallyInside(p,hole)&&(tan<tanMin||(tan===tanMin&&(p.x>m.x||(p.x===m.x&&sectorContainsSector(m,p)))))){m=p;tanMin=tan;}}p=p.next;}while(p!==stop);return m;}function indexCurve(start,minX,minY,invSize){var p=start;do{if(p.z===null)p.z=zOrder(p.x,p.y,minX,minY,invSize);p.prevZ=p.prev;p.nextZ=p.next;p=p.next;}while(p!==start);p.prevZ.nextZ=null;p.prevZ=null;sortLinked(p);}function sortLinked(list){var i,p,q,e,tail,numMerges,pSize,qSize,inSize=1;do{p=list;list=null;tail=null;numMerges=0;while(p){numMerges++;q=p;pSize=0;for(i=0;i<inSize;i++){pSize++;q=q.nextZ;if(!q)break;}qSize=inSize;while(pSize>0||(qSize>0&&q)){if(pSize===0){e=q;q=q.nextZ;qSize--;}else if(qSize===0||!q){e=p;p=p.nextZ;pSize--;}else if(p.z<=q.z){e=p;p=p.nextZ;pSize--;}else{e=q;q=q.nextZ;qSize--;}if(tail)tail.nextZ=e;else list=e;e.prevZ=tail;tail=e;}p=q;}tail.nextZ=null;inSize*=2;}while(numMerges>1);return list;}function zOrder(x,y,minX,minY,invSize){x=32767*(x-minX)*invSize;y=32767*(y-minY)*invSize;x=(x|(x<<8))&0x00FF00FF;x=(x|(x<<4))&0x0F0F0F0F;x=(x|(x<<2))&0x33333333;x=(x|(x<<1))&0x55555555;y=(y|(y<<8))&0x00FF00FF;y=(y|(y<<4))&0x0F0F0F0F;y=(y|(y<<2))&0x33333333;y=(y|(y<<1))&0x55555555;return x|(y<<1);}function getLeftmost(start){var p=start,leftmost=start;do{if(p.x<leftmost.x||(p.x===leftmost.x&&p.y<leftmost.y))leftmost=p;p=p.next;}while(p!==start);return leftmost;}function pointInTriangle(ax,ay,bx,by,cx,cy,px,py){return(cx-px)*(ay-py)-(ax-px)*(cy-py)>=0&&(ax-px)*(by-py)-(bx-px)*(ay-py)>=0&&(bx-px)*(cy-py)-(cx-px)*(by-py)>=0;}function isValidDiagonal(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!intersectsPolygon(a,b)&&(locallyInside(a,b)&&locallyInside(b,a)&&middleInside(a,b)&&(area(a.prev,a,b.prev)||area(a,b.prev,b))||equals(a,b)&&area(a.prev,a,a.next)>0&&area(b.prev,b,b.next)>0);}function area(p,q,r){return(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);}function equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y;}function intersects(p1,q1,p2,q2){var o1=sign(area(p1,q1,p2)),o2=sign(area(p1,q1,q2)),o3=sign(area(p2,q2,p1)),o4=sign(area(p2,q2,q1));if(o1!==o2&&o3!==o4)return true;return false;}function intersectsPolygon(a,b){var p=a;do{if(p.i!==a.i&&p.next.i!==a.i&&p.i!==b.i&&p.next.i!==b.i&&intersects(p,p.next,a,b))return true;p=p.next;}while(p!==a);return false;}function locallyInside(a,b){return area(a.prev,a,a.next)<0?area(a,b,a.next)>=0&&area(a,a.prev,b)>=0:area(a,b,a.prev)<0||area(a,a.next,b)<0;}function middleInside(a,b){var p=a,inside=false,px=(a.x+b.x)/2,py=(a.y+b.y)/2;do{if(((p.y>py)!==(p.next.y>py))&&p.next.y!==p.y&&(px<(p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x))inside=!inside;p=p.next;}while(p!==a);return inside;}function splitPolygon(a,b){var a2=new Node(a.i,a.x,a.y),b2=new Node(b.i,b.x,b.y),an=a.next,bp=b.prev;a.next=b;b.prev=a;a2.next=an;an.prev=a2;b2.next=a2;a2.prev=b2;bp.next=b2;b2.prev=bp;return b2;}function insertNode(i,x,y,last){var p=new Node(i,x,y);if(!last){p.prev=p;p.next=p;}else{p.next=last.next;p.prev=last;last.next.prev=p;last.next=p;}return p;}function removeNode(p){p.next.prev=p.prev;p.prev.next=p.next;if(p.prevZ)p.prevZ.nextZ=p.nextZ;if(p.nextZ)p.nextZ.prevZ=p.prevZ;}function Node(i,x,y){this.i=i;this.x=x;this.y=y;this.prev=null;this.next=null;this.z=null;this.prevZ=null;this.nextZ=null;this.steiner=false;}function sign(num){return num>0?1:num<0?-1:0;}function signedArea(data,start,end,dim){var sum=0,j=end-dim;for(var i=start;i<end;i+=dim){sum+=(data[j]-data[i])*(data[i+1]+data[j+1]);j=i;}return sum;}function compareX(a,b){return a.x-b.x;}return earcut;})();

// --- æ ¸å¿ƒç®—æ³• 2: è¿­ä»£å¼ RDP ---
function simplifyPoints(points, tolerance) {
    if (points.length <= 2) return points;
    const sqTolerance = tolerance * tolerance;
    const len = points.length;
    const markers = new Uint8Array(len);
    markers[0] = 1; markers[len - 1] = 1;
    const stack = [0, len - 1];
    while (stack.length > 0) {
        const last = stack.pop(), first = stack.pop();
        let maxSqDist = 0, index = -1;
        let x1 = points[first].x, y1 = points[first].y, x2 = points[last].x, y2 = points[last].y;
        let dx = x2 - x1, dy = y2 - y1, segLenSq = dx * dx + dy * dy;
        if (segLenSq === 0) {
             for (let i = first + 1; i < last; i++) {
                let d = (points[i].x - x1)**2 + (points[i].y - y1)**2;
                if (d > maxSqDist) { index = i; maxSqDist = d; }
             }
        } else {
            for (let i = first + 1; i < last; i++) {
                let px = points[i].x, py = points[i].y;
                let t = ((px - x1) * dx + (py - y1) * dy) / segLenSq;
                let cx = (t <= 0) ? x1 : (t >= 1 ? x2 : x1 + t * dx);
                let cy = (t <= 0) ? y1 : (t >= 1 ? y2 : y1 + t * dy);
                let d = (px - cx)**2 + (py - cy)**2;
                if (d > maxSqDist) { index = i; maxSqDist = d; }
            }
        }
        if (maxSqDist > sqTolerance) { markers[index] = 1; stack.push(index, last, first, index); }
    }
    const newPoints = [];
    for (let i = 0; i < len; i++) if (markers[i]) newPoints.push(points[i]);
    return newPoints;
}

// --- æ ¸å¿ƒç®—æ³• 3: è½®å»“æ¸…æ´— (é˜²æ­¢é‡å ç‚¹ & å…±çº¿ç‚¹) ---
function cleanContour(points, minDistance = 1.0) {
    if (points.length < 3) return points;
    let clean = [];
    const distSq = minDistance * minDistance;

    // 1. è·ç¦»è¿‡æ»¤
    clean.push(points[0]);
    for (let i = 1; i < points.length; i++) {
        const last = clean[clean.length - 1];
        const curr = points[i];
        const d = (curr.x - last.x) ** 2 + (curr.y - last.y) ** 2;
        if (d >= distSq) {
            clean.push(curr);
        }
    }
    // é—­åˆæ£€æŸ¥
    if (clean.length > 2) {
        const first = clean[0];
        const last = clean[clean.length - 1];
        if ((first.x - last.x) ** 2 + (first.y - last.y) ** 2 < distSq) {
            clean.pop();
        }
    }
    
    // 2. å…±çº¿è¿‡æ»¤ (ç§»é™¤å¯¹å½¢çŠ¶è´¡çŒ®æå°çš„ä¸­é—´ç‚¹)
    if (clean.length > 2) {
        const finalPass = [];
        finalPass.push(clean[0]);
        for(let i=1; i<clean.length-1; i++) {
            const prev = clean[i-1];
            const curr = clean[i];
            const next = clean[i+1];
            // è®¡ç®—ä¸‰è§’å½¢é¢ç§¯ï¼Œå¦‚æœéå¸¸å°åˆ™å…±çº¿
            const area = Math.abs((curr.x - prev.x)*(next.y - prev.y) - (curr.y - prev.y)*(next.x - prev.x));
            if (area > 0.5) { // é˜ˆå€¼ï¼Œé¢ç§¯å¤§äº0.5æ‰ä¿ç•™
                finalPass.push(curr);
            }
        }
        finalPass.push(clean[clean.length-1]);
        clean = finalPass;
    }

    return clean;
}

// --- æ ¸å¿ƒç®—æ³• 4: ç»ˆææ‹“æ‰‘ä¼˜åŒ– (ä¸¥æ ¼å‡¸æ€§æ£€æµ‹) ---
// å½»åº•è§£å†³äº¤å‰é—®é¢˜ï¼šæ”¾å¼ƒç›¸äº¤æ£€æµ‹ï¼Œä½¿ç”¨ 4-Corner å‡¸æ€§æ£€æµ‹
function optimizeMeshTopology(vertices, indices, iterations = 8) {
    // 2D å‰ç§¯ (æœ‰å‘é¢ç§¯)
    function orient2d(ax, ay, bx, by, cx, cy) {
        return (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);
    }

    // Delaunay æ¡ä»¶ (ç‚¹ D æ˜¯å¦åœ¨ ABC å¤–æ¥åœ†å†…)
    function inCircle(a, b, c, d) {
        const ax = a.x - d.x, ay = a.y - d.y;
        const bx = b.x - d.x, by = b.y - d.y;
        const cx = c.x - d.x, cy = c.y - d.y;
        return (
            (ax * ax + ay * ay) * (bx * cy - cx * by) -
            (bx * bx + by * by) * (ax * cy - cx * ay) +
            (cx * cx + cy * cy) * (ax * by - bx * ay)
        ) > 1e-9; 
    }

    // æ£€æŸ¥å››è¾¹å½¢ ABCD æ˜¯å¦ä¸¥æ ¼å‡¸ (Strictly Convex)
    // åªæœ‰ä¸¥æ ¼å‡¸å››è¾¹å½¢ï¼Œå¯¹è§’çº¿ç¿»è½¬æ‰æ˜¯å‡ ä½•å®‰å…¨çš„
    function isStrictlyConvex(a, b, c, d) {
        // å‡è®¾é¡ºåºæ˜¯ (a, b, c) å’Œ (a, c, d) ç»„æˆçš„å››è¾¹å½¢ a-b-c-d
        // éœ€è¦æ£€æŸ¥å››ä¸ªè§’çš„è½¬å‘æ˜¯å¦ä¸€è‡´ (å…¨éƒ¨ > 0)
        // æ³¨æ„ä¼ å…¥é¡ºåºï¼šA, B, C, D å¿…é¡»æ˜¯é€†æ—¶é’ˆæ’åˆ—çš„å››è¾¹å½¢é¡¶ç‚¹
        
        // ä¸‰è§’å½¢ T1: A, B, C. T2: A, C, D. 
        // å®é™…å››è¾¹å½¢é¡¶ç‚¹é¡ºåºæ˜¯ A -> B -> C -> D
        
        const cp1 = orient2d(a.x, a.y, b.x, b.y, c.x, c.y); // B åœ¨ AC å·¦ä¾§?
        const cp2 = orient2d(b.x, b.y, c.x, c.y, d.x, d.y); // C åœ¨ BD å·¦ä¾§?
        const cp3 = orient2d(c.x, c.y, d.x, d.y, a.x, a.y); // D åœ¨ CA å·¦ä¾§?
        const cp4 = orient2d(d.x, d.y, a.x, a.y, b.x, b.y); // A åœ¨ DB å·¦ä¾§?
        
        // æ‰€æœ‰å‰ç§¯å¿…é¡»åŒå·ä¸”éé›¶ (ä¸¥æ ¼å‡¸)
        // è¿™é‡Œçš„é€»è¾‘å‡è®¾äº†ç‰¹å®šçš„ç»•åºï¼Œæˆ‘ä»¬ç®€åŒ–ä¸ºï¼šå¯¹è§’çº¿å¿…é¡»å®Œå…¨åœ¨å†…éƒ¨
        // æ›´ç®€å•çš„åˆ¤å®šï¼šæ–°çš„å¯¹è§’çº¿ BD ä¸ AC å¿…é¡»æœ‰ä¸¥æ ¼çš„ç‰©ç†ç›¸äº¤
        
        // å›å½’ç‰©ç†ç›¸äº¤æ£€æµ‹ï¼Œä½†è¿™æ¬¡ä¸ä»…æ£€æµ‹å¯¹è§’çº¿ï¼Œè¿˜æ£€æµ‹æ˜¯å¦é€€åŒ–
        return segmentsIntersectStrict(a, c, b, d);
    }
    
    // ä¸¥æ ¼çº¿æ®µç›¸äº¤ (è·¨ç«‹å®éªŒ) - ç”¨äºåˆ¤å®šæ˜¯å¦ä¸ºå‡¸å››è¾¹å½¢
    function segmentsIntersectStrict(a, b, c, d) {
        const cp1 = orient2d(a.x, a.y, b.x, b.y, c.x, c.y);
        const cp2 = orient2d(a.x, a.y, b.x, b.y, d.x, d.y);
        const cp3 = orient2d(c.x, c.y, d.x, d.y, a.x, a.y);
        const cp4 = orient2d(c.x, c.y, d.x, d.y, b.x, b.y);
        // å¿…é¡»ä¸¥æ ¼è·¨ç«‹ (ä¹˜ç§¯ < 0)
        return (cp1 * cp2 < -1e-9) && (cp3 * cp4 < -1e-9);
    }

    for (let iter = 0; iter < iterations; iter++) {
        let flipped = false;
        const edgeMap = new Map();

        // æ„å»ºè¾¹ç´¢å¼•
        for (let i = 0; i < indices.length; i += 3) {
            for (let j = 0; j < 3; j++) {
                const v1 = indices[i + j];
                const v2 = indices[i + (j + 1) % 3];
                const key = v1 < v2 ? `${v1}_${v2}` : `${v2}_${v1}`;
                if (!edgeMap.has(key)) edgeMap.set(key, []);
                edgeMap.get(key).push({ triIdx: i, localIdx: j });
            }
        }

        // éå†æ‰€æœ‰å†…éƒ¨å…±äº«è¾¹
        for (const [key, shared] of edgeMap) {
            if (shared.length !== 2) continue;

            const t1Base = shared[0].triIdx;
            const t2Base = shared[1].triIdx;
            const t1Local = shared[0].localIdx;
            
            // T1 é¡¶ç‚¹: A, B, C (BC æ˜¯å…±äº«è¾¹)
            const iA = indices[t1Base + (t1Local + 2) % 3];
            const iB = indices[t1Base + t1Local];
            const iC = indices[t1Base + (t1Local + 1) % 3];

            // T2 é¡¶ç‚¹: D (ç›¸å¯¹é¡¶ç‚¹)
            let iD = -1;
            for (let k = 0; k < 3; k++) {
                const idx = indices[t2Base + k];
                if (idx !== iB && idx !== iC) { iD = idx; break; }
            }
            if (iD === -1) continue;

            const A = vertices[iA], B = vertices[iB], C = vertices[iC], D = vertices[iD];

            // --- æ ¸å¿ƒä¿®å¤ ---
            // åˆ¤å®šï¼šå››è¾¹å½¢ ABDC æ˜¯å¦æ˜¯ä¸¥æ ¼å‡¸å››è¾¹å½¢ï¼Ÿ
            // åˆ¤å®šæ–¹æ³•ï¼šåŸå¯¹è§’çº¿ BC ä¸ æ½œåœ¨å¯¹è§’çº¿ AD å¿…é¡»ä¸¥æ ¼ç›¸äº¤ã€‚
            // åªæœ‰ç›¸äº¤ï¼Œå››è¾¹å½¢æ‰æ˜¯å‡¸çš„ï¼Œç¿»è½¬æ‰ä¸ä¼šäº§ç”Ÿé‡å ã€‚
            if (!segmentsIntersectStrict(B, C, A, D)) continue;

            // --- ä¼˜åŒ–ç›®æ ‡: Delaunay ---
            // å¦‚æœç‚¹ D åœ¨ä¸‰è§’å½¢ ABC çš„å¤–æ¥åœ†å†…ï¼Œåˆ™ç¿»è½¬èƒ½ä¼˜åŒ–è§’åº¦
            if (inCircle(A, B, C, D)) {
                indices[t1Base] = iA; indices[t1Base + 1] = iB; indices[t1Base + 2] = iD;
                indices[t2Base] = iA; indices[t2Base + 1] = iD; indices[t2Base + 2] = iC;
                flipped = true;
            }
        }
        if (!flipped) break;
    }
    return indices;
}

const ImageProcessor = {
    threshold: function(imageData, threshold, keyColor, colorTolerance) {
        const width = imageData.width, height = imageData.height, data = imageData.data;
        const grid = new Uint8Array(width * height);
        for (let i = 0; i < width * height; i++) {
            const r = data[i*4], g = data[i*4+1], b = data[i*4+2], a = data[i*4+3];
            let isBackground = false;
            if (keyColor) {
                const dist = Math.sqrt((r-keyColor[0])**2 + (g-keyColor[1])**2 + (b-keyColor[2])**2);
                isBackground = dist <= colorTolerance; 
            } else {
                isBackground = a <= threshold;
            }
            grid[i] = isBackground ? 0 : 1; 
        }
        return { grid, width, height };
    },
    dilate: function(binaryImg, radius) {
        if (radius <= 0) return binaryImg;
        const { grid, width, height } = binaryImg;
        const newGrid = new Uint8Array(width * height);
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (grid[y * width + x] === 1) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const ny = y + dy, nx = x + dx;
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) newGrid[ny * width + nx] = 1;
                        }
                    }
                }
            }
        }
        return { grid: newGrid, width, height };
    },
    findContours: function(binaryImg) {
        const { grid, width, height } = binaryImg;
        const paddedW = width + 2, paddedH = height + 2;
        const paddedGrid = new Uint8Array(paddedW * paddedH);
        for(let y=0; y<height; y++) for(let x=0; x<width; x++) if(grid[y*width+x]===1) paddedGrid[(y+1)*paddedW+(x+1)]=1;
        const queue = [0]; paddedGrid[0] = 2;
        while(queue.length > 0) {
            const idx = queue.pop();
            const dirs = [-1, 1, -paddedW, paddedW];
            for(let d of dirs) {
                const nIdx = idx + d;
                if(nIdx>=0 && nIdx<paddedGrid.length && paddedGrid[nIdx]===0) {
                    paddedGrid[nIdx]=2; queue.push(nIdx);
                }
            }
        }
        const contours = [];
        const visited = new Uint8Array(paddedW * paddedH);
        for (let y = 1; y < paddedH - 1; y++) {
            for (let x = 1; x < paddedW - 1; x++) {
                const idx = y * paddedW + x;
                if (paddedGrid[idx] === 1 && paddedGrid[idx - 1] === 2 && visited[idx] === 0) {
                    const contour = ImageProcessor.traceContour(paddedGrid, visited, x, y, paddedW, paddedH);
                    if (contour.length > 0) contours.push(contour.map(p => ({x: p.x - 1, y: p.y - 1})));
                }
            }
        }
        return contours;
    },
    traceContour: function(grid, visited, startX, startY, w, h) {
        const contour = [];
        let cx = startX, cy = startY;
        const dirs = [{x:0, y:-1}, {x:1, y:-1}, {x:1, y:0}, {x:1, y:1}, {x:0, y:1}, {x:-1, y:1}, {x:-1, y:0}, {x:-1, y:-1}];
        let dirIdx = 6;
        let loops = 0; const maxLoops = w * h * 2;
        do {
            contour.push({x: cx, y: cy});
            visited[cy * w + cx] = 1;
            let found = false;
            const startDir = (dirIdx + 6) % 8;
            for (let i = 0; i < 8; i++) {
                const idx = (startDir + i) % 8;
                const nx = cx + dirs[idx].x, ny = cy + dirs[idx].y;
                if (grid[ny * w + nx] === 1) {
                    cx = nx; cy = ny; dirIdx = idx; found = true; break;
                }
            }
            if (!found) break;
            loops++;
        } while ((cx !== startX || cy !== startY) && loops < maxLoops);
        return contour;
    }
};

// --- åº”ç”¨çŠ¶æ€ ---
let originalImage = null;
let processedMeshes = [];
let previewMask = null; 
let scale = 1.0, offsetX = 0, offsetY = 0, isDragging = false, lastMousePos = {x:0,y:0};
let keyColor = null;
let thresholdState = { alpha: 50, color: 30 };
let appMode = 'mask'; // 'mask' æˆ– 'mesh'
let meshGenerationCancel = false;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const statusBar = document.getElementById('statusBar');
const polyCountDisplay = document.getElementById('polyCount');
const modeBadge = document.getElementById('modeBadge');
const progressContainer = document.getElementById('progressContainer');
const progressBar = document.getElementById('progressBar');

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function resizeCanvas() {
    canvas.width = document.getElementById('mainView').clientWidth;
    canvas.height = document.getElementById('mainView').clientHeight;
    if (originalImage) requestAnimationFrame(draw);
}

function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;
    statusBar.innerText = "æ­£åœ¨è¯»å–å›¾ç‰‡...";
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
            originalImage = img;
            scale = Math.min((canvas.width * 0.8) / img.width, (canvas.height * 0.8) / img.height);
            offsetX = (canvas.width - img.width * scale) / 2;
            offsetY = (canvas.height - img.height * scale) / 2;
            document.getElementById('exportBtn').disabled = true;
            document.getElementById('generateBtn').disabled = false;
            
            const maxDimension = Math.max(img.width, img.height);
            let autoPrecision = 20; 
            if (maxDimension > 4000) autoPrecision = 120;
            else if (maxDimension > 2000) autoPrecision = 80; 
            else if (maxDimension > 1000) autoPrecision = 40; 
            document.getElementById('precision').value = autoPrecision;
            document.getElementById('val-precision').innerText = (autoPrecision * 0.1).toFixed(1) + "px";
            
            detectTransparencyAndSwitch(img);
        }
        img.src = e.target.result;
    }
    reader.readAsDataURL(file);
}

function detectTransparencyAndSwitch(img) {
    const tc = document.createElement('canvas'); tc.width = img.width; tc.height = img.height;
    tc.getContext('2d').drawImage(img, 0, 0);
    const data = tc.getContext('2d').getImageData(0, 0, img.width, img.height).data;
    let hasTransparency = false;
    for (let i = 3; i < data.length; i += 4) {
        if (data[i] < 250) { hasTransparency = true; break; }
    }
    const colorPickerMode = document.getElementById('colorPickerMode');
    if (!hasTransparency) {
        colorPickerMode.checked = true;
        statusBar.innerText = "æ— é€æ˜é€šé“ -> å·²åˆ‡è‡³å¸è‰²æ¨¡å¼";
    } else {
        colorPickerMode.checked = false;
        statusBar.innerText = "æ£€æµ‹åˆ°é€æ˜ -> Alphaæ¨¡å¼";
    }
    toggleColorPicker();
    updateMaskPreview();
}

function setAppMode(mode) {
    appMode = mode;
    modeBadge.classList.remove('hidden', 'mode-mask', 'mode-mesh');
    if (mode === 'mask') {
        modeBadge.innerText = "é¢„è§ˆé®ç½© (Preview)";
        modeBadge.classList.add('mode-mask');
        document.getElementById('exportBtn').disabled = true;
        document.getElementById('generateBtn').classList.remove('secondary');
        document.getElementById('generateBtn').innerText = "â–¶ ç”Ÿæˆç½‘æ ¼";
    } else {
        modeBadge.innerText = "ç½‘æ ¼è§†å›¾ (Mesh)";
        modeBadge.classList.add('mode-mesh');
        document.getElementById('exportBtn').disabled = false;
        document.getElementById('generateBtn').classList.add('secondary');
        document.getElementById('generateBtn').innerText = "â†» é‡æ–°ç”Ÿæˆ";
    }
    requestAnimationFrame(draw);
}

function updateMaskPreview() {
    if (!originalImage) return;
    
    ['commonThreshold', 'expansion'].forEach(id => {
        document.getElementById('val-'+id).innerText = document.getElementById(id).value;
    });

    setAppMode('mask');
    processedMeshes = [];

    const commonVal = parseInt(document.getElementById('commonThreshold').value);
    const expansionVal = parseInt(document.getElementById('expansion').value);
    let threshVal, tolerance;
    if (keyColor) {
        threshVal = 0; tolerance = commonVal * 1.5; 
        thresholdState.color = commonVal;
    } else {
        threshVal = commonVal * 2.55; tolerance = 0;
        thresholdState.alpha = commonVal;
    }

    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = originalImage.width;
    tempCanvas.height = originalImage.height;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(originalImage, 0, 0);
    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    
    let binary = ImageProcessor.threshold(imageData, threshVal, keyColor, tolerance);
    if (expansionVal > 0) binary = ImageProcessor.dilate(binary, expansionVal);

    const maskData = new ImageData(binary.width, binary.height);
    const buf = maskData.data;
    for (let i = 0; i < binary.width * binary.height; i++) {
        buf[i*4] = 255;   // R
        buf[i*4+1] = 0;   // G
        buf[i*4+2] = 0;   // B
        buf[i*4+3] = binary.grid[i] ? 100 : 0; // Alpha
    }
    
    const maskCanvas = document.createElement('canvas');
    maskCanvas.width = binary.width;
    maskCanvas.height = binary.height;
    maskCanvas.getContext('2d').putImageData(maskData, 0, 0);
    
    previewMask = maskCanvas;
    requestAnimationFrame(draw);
}

function startMeshGeneration() {
    if (!originalImage) return;
    meshGenerationCancel = false;
    
    document.getElementById('generateBtn').disabled = true;
    progressContainer.style.display = 'block';
    progressBar.style.width = '0%';
    statusBar.innerText = "å‡†å¤‡è®¡ç®—...";
    
    appMode = 'mesh'; 
    modeBadge.classList.remove('hidden', 'mode-mask');
    modeBadge.classList.add('mode-mesh');
    modeBadge.innerText = "æ­£åœ¨è®¡ç®— (Calculating)";

    setTimeout(() => {
        try {
            const commonVal = parseInt(document.getElementById('commonThreshold').value);
            const expansionVal = parseInt(document.getElementById('expansion').value);
            let threshVal, tolerance;
            if (keyColor) { threshVal = 0; tolerance = commonVal * 1.5; } else { threshVal = commonVal * 2.55; tolerance = 0; }

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = originalImage.width; tempCanvas.height = originalImage.height;
            tempCanvas.getContext('2d').drawImage(originalImage, 0, 0);
            const imageData = tempCanvas.getContext('2d').getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            
            let binary = ImageProcessor.threshold(imageData, threshVal, keyColor, tolerance);
            if (expansionVal > 0) binary = ImageProcessor.dilate(binary, expansionVal);

            const rawContours = ImageProcessor.findContours(binary);
            const precisionSlider = parseInt(document.getElementById('precision').value);
            const pixelTolerance = precisionSlider * 0.1;
            
            processedMeshes = [];
            processContoursAsync(rawContours, pixelTolerance);
            
        } catch (e) {
            console.error(e);
            statusBar.innerText = "é”™è¯¯: " + e.message;
            document.getElementById('generateBtn').disabled = false;
        }
    }, 50);
}

function processContoursAsync(contours, tolerance) {
    let index = 0;
    let totalVerts = 0;
    let totalTris = 0;
    const total = contours.length;

    function loop() {
        if (meshGenerationCancel) return;
        
        const loopStart = performance.now();
        while (index < total && performance.now() - loopStart < 16) {
            const contour = contours[index];
            
            let perimeter = 0;
            for(let i=0; i<contour.length; i++) {
                const p1 = contour[i], p2 = contour[(i+1)%contour.length];
                perimeter += Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2);
            }
            
            if (perimeter > 20 && contour.length > 5) {
                let safeTolerance = tolerance;
                if (contour.length > 3000 && safeTolerance < 1.0) safeTolerance = 1.0; 
                if (contour.length > 10000 && safeTolerance < 3.0) safeTolerance = 3.0;

                // 1. ç®€åŒ– (RDP)
                let simplified = simplifyPoints(contour, safeTolerance);
                
                // 2. æ¸…æ´— (å…³é”®ä¿®å¤ï¼šå»é™¤è·ç¦» < 1.5px çš„ç‚¹ å’Œ å…±çº¿ç‚¹)
                simplified = cleanContour(simplified, 1.5);

                if (simplified.length >= 3) {
                    const flatCoords = [];
                    simplified.forEach(p => flatCoords.push(p.x, p.y));
                    
                    // 3. Earcut
                    let indices = earcut(flatCoords);
                    
                    // 4. ä¼˜åŒ– (ä¸¥æ ¼å‡¸æ€§æ£€æµ‹)
                    if (indices.length > 0) {
                        indices = optimizeMeshTopology(simplified, indices, 6);
                    }

                    processedMeshes.push({ vertices: simplified, indices: indices });
                    totalVerts += simplified.length;
                    totalTris += indices.length / 3;
                }
            }
            index++;
        }

        const percent = Math.floor((index / total) * 100);
        progressBar.style.width = percent + '%';
        statusBar.innerText = `è®¡ç®—ä¸­... ${index}/${total} è½®å»“`;
        
        requestAnimationFrame(draw); 

        if (index < total) {
            requestAnimationFrame(loop);
        } else {
            progressContainer.style.display = 'none';
            document.getElementById('generateBtn').disabled = false;
            statusBar.innerText = `å®Œæˆï¼ç‚¹: ${totalVerts} | é¢: ${totalTris}`;
            polyCountDisplay.innerText = `${totalTris} tris`;
            setAppMode('mesh');
        }
    }
    
    loop();
}

function updateMeshIfPossible() {
    const precisionVal = document.getElementById('precision').value;
    document.getElementById('val-precision').innerText = (precisionVal * 0.1).toFixed(1) + "px";
    
    if (appMode === 'mesh' && processedMeshes.length > 0) {
        if (window.meshDebounce) clearTimeout(window.meshDebounce);
        window.meshDebounce = setTimeout(startMeshGeneration, 300);
    }
}

function draw() {
    ctx.fillStyle = "#1e1e1e";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    const size = 20;
    ctx.fillStyle = "#252525";
    for(let y=0; y<canvas.height; y+=size) for(let x=0; x<canvas.width; x+=size) if ((x/size + y/size) % 2 === 0) ctx.fillRect(x, y, size, size);

    if (!originalImage) return;

    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);

    ctx.globalAlpha = (appMode === 'mask') ? 0.8 : 0.4; 
    ctx.drawImage(originalImage, 0, 0);
    ctx.globalAlpha = 1.0;

    if (appMode === 'mask') {
        const showMask = document.getElementById('showMaskPreview').checked;
        if (previewMask && showMask) ctx.drawImage(previewMask, 0, 0);
    } else if (appMode === 'mesh') {
        const showWire = document.getElementById('showWireframe').checked;
        const showPoints = document.getElementById('showPoints').checked;
        
        if (processedMeshes.length > 0) {
            processedMeshes.forEach(mesh => {
                const verts = mesh.vertices;
                const inds = mesh.indices;
                
                ctx.strokeStyle = "#ff3333";
                ctx.lineWidth = 1.5 / scale;
                ctx.lineJoin = 'round';
                ctx.beginPath();
                if(verts.length > 0) {
                    ctx.moveTo(verts[0].x, verts[0].y);
                    for(let i=1; i<verts.length; i++) ctx.lineTo(verts[i].x, verts[i].y);
                    ctx.closePath();
                }
                ctx.stroke();

                if (showWire) {
                    ctx.strokeStyle = "rgba(0, 255, 255, 0.5)"; 
                    ctx.lineWidth = 0.5 / scale;
                    ctx.beginPath();
                    for (let i = 0; i < inds.length; i += 3) {
                        const p1 = verts[inds[i]];
                        const p2 = verts[inds[i+1]];
                        const p3 = verts[inds[i+2]];
                        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                        ctx.lineTo(p3.x, p3.y); ctx.lineTo(p1.x, p1.y);
                    }
                    ctx.stroke();
                }
                
                if (showPoints) {
                     ctx.fillStyle = "#ffff00";
                     const pSize = Math.max(1, 3 / scale); 
                     for(let i=0; i<verts.length; i++) {
                         ctx.fillRect(verts[i].x - pSize/2, verts[i].y - pSize/2, pSize, pSize);
                     }
                }
            });
        }
    }
    ctx.restore();
}

const mainView = document.getElementById('mainView');
mainView.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left; 
    const my = e.clientY - rect.top;
    
    const delta = e.deltaY > 0 ? 0.9 : 1.1;
    const newScale = Math.min(Math.max(0.01, scale * delta), 50.0);
    
    offsetX = mx - (mx - offsetX) * (newScale / scale);
    offsetY = my - (my - offsetY) * (newScale / scale);
    
    if (!Number.isFinite(offsetX)) offsetX = 0;
    if (!Number.isFinite(offsetY)) offsetY = 0;
    
    scale = newScale;
    requestAnimationFrame(draw);
}, { passive: false });

mainView.addEventListener('mousedown', (e) => {
    if (document.getElementById('colorPickerMode').checked && e.button === 0) {
        pickColor(e);
    } else if (e.button === 0) {
        isDragging = true; lastMousePos = { x: e.clientX, y: e.clientY };
    }
});
window.addEventListener('mouseup', () => isDragging = false);
window.addEventListener('mousemove', (e) => {
    if (isDragging) {
        offsetX += e.clientX - lastMousePos.x;
        offsetY += e.clientY - lastMousePos.y;
        lastMousePos = { x: e.clientX, y: e.clientY };
        requestAnimationFrame(draw);
    }
});

function resetView() {
    if(!originalImage) return;
    scale = Math.min((canvas.width*0.8)/originalImage.width, (canvas.height*0.8)/originalImage.height);
    offsetX = (canvas.width-originalImage.width*scale)/2;
    offsetY = (canvas.height-originalImage.height*scale)/2;
    requestAnimationFrame(draw);
}

function toggleColorPicker() {
    const on = document.getElementById('colorPickerMode').checked;
    const toggleBtn = document.getElementById('eyedropperBtn');
    const label = document.getElementById('thresholdLabel');
    const slider = document.getElementById('commonThreshold');
    const valDisplay = document.getElementById('val-commonThreshold');
    const keyColorDisplay = document.getElementById('keyColorDisplay');

    if (on) {
        toggleBtn.classList.add('active');
        mainView.classList.add('picking');
        label.innerText = "é¢œè‰²å®¹å·® (Similarity)";
        keyColorDisplay.classList.remove('hidden');
        slider.value = thresholdState.color;
        valDisplay.innerText = thresholdState.color;
        if (!keyColor) statusBar.innerText = ">> è¯·åœ¨å›¾ç‰‡ä¸Šç‚¹å‡»è¦ä¿ç•™çš„é¢œè‰² <<";
    } else {
        toggleBtn.classList.remove('active');
        mainView.classList.remove('picking');
        if (keyColor) {
            label.innerText = "é¢œè‰²å®¹å·® (Similarity)";
            keyColorDisplay.classList.remove('hidden');
            slider.value = thresholdState.color;
            valDisplay.innerText = thresholdState.color;
        } else {
            label.innerText = "é€æ˜åº¦é˜ˆå€¼ (Alpha)";
            keyColorDisplay.classList.add('hidden');
            slider.value = thresholdState.alpha;
            valDisplay.innerText = thresholdState.alpha;
        }
        updateMaskPreview();
    }
}

function pickColor(e) {
    if (!originalImage) return;
    const rect = canvas.getBoundingClientRect();
    const ix = Math.floor((e.clientX - rect.left - offsetX) / scale);
    const iy = Math.floor((e.clientY - rect.top - offsetY) / scale);
    if (ix >= 0 && ix < originalImage.width && iy >= 0 && iy < originalImage.height) {
        const tc = document.createElement('canvas'); tc.width=1; tc.height=1;
        tc.getContext('2d').drawImage(originalImage, ix, iy, 1, 1, 0, 0, 1, 1);
        const p = tc.getContext('2d').getImageData(0,0,1,1).data;
        keyColor = [p[0], p[1], p[2]];
        
        document.getElementById('keyColorBox').style.background = `rgb(${p[0]},${p[1]},${p[2]})`;
        document.getElementById('keyColorText').innerText = `R:${p[0]} G:${p[1]} B:${p[2]}`;
        
        document.getElementById('colorPickerMode').checked = false;
        toggleColorPicker(); 
        
        statusBar.innerText = "é¢œè‰²å·²é€‰å®šï¼Œæ­£åœ¨æ›´æ–°é®ç½©é¢„è§ˆ...";
        updateMaskPreview();
    }
}

function clearKeyColor() {
    keyColor = null;
    document.getElementById('colorPickerMode').checked = true;
    toggleColorPicker();
    updateMaskPreview();
}

function exportModel() {
    if (processedMeshes.length === 0) { alert("æ²¡æœ‰ç”Ÿæˆç½‘æ ¼æ•°æ®"); return; }
    let objContent = "# Generated by PNG2Mesh (Convex Fix)\n";
    let globalVertCount = 0;
    const imgWidth = originalImage.width;
    const imgHeight = originalImage.height;
    const aspectRatio = imgWidth / imgHeight;
    processedMeshes.forEach(mesh => {
        const verts = mesh.vertices;
        const inds = mesh.indices;
        verts.forEach(p => {
            const vx = (p.x / imgWidth - 0.5) * 2 * aspectRatio;
            const vy = -(p.y / imgHeight - 0.5) * 2; 
            const vz = 0;
            const u = p.x / imgWidth;
            const v = 1.0 - (p.y / imgHeight);
            objContent += `v ${vx.toFixed(6)} ${vy.toFixed(6)} ${vz.toFixed(6)}\n`;
            objContent += `vt ${u.toFixed(6)} ${v.toFixed(6)}\n`;
        });
        for (let i = 0; i < inds.length; i += 3) {
            const idx1 = globalVertCount + inds[i] + 1;
            const idx2 = globalVertCount + inds[i+1] + 1;
            const idx3 = globalVertCount + inds[i+2] + 1;
            objContent += `f ${idx1}/${idx1} ${idx2}/${idx2} ${idx3}/${idx3}\n`;
        }
        globalVertCount += verts.length;
    });
    const blob = new Blob([objContent], {type: "text/plain"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = "model_convex_fix.obj";
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
</script>
</body>
</html>